"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/consola";
exports.ids = ["vendor-chunks/consola"];
exports.modules = {

/***/ "(rsc)/./node_modules/consola/dist/core.mjs":
/*!********************************************!*\
  !*** ./node_modules/consola/dist/core.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Consola: () => (/* binding */ Consola),\n/* harmony export */   LogLevels: () => (/* binding */ LogLevels),\n/* harmony export */   LogTypes: () => (/* binding */ LogTypes),\n/* harmony export */   createConsola: () => (/* binding */ createConsola)\n/* harmony export */ });\nconst LogLevels = {\n  silent: Number.NEGATIVE_INFINITY,\n  fatal: 0,\n  error: 0,\n  warn: 1,\n  log: 2,\n  info: 3,\n  success: 3,\n  fail: 3,\n  ready: 3,\n  start: 3,\n  box: 3,\n  debug: 4,\n  trace: 5,\n  verbose: Number.POSITIVE_INFINITY\n};\nconst LogTypes = {\n  // Silent\n  silent: {\n    level: -1\n  },\n  // Level 0\n  fatal: {\n    level: LogLevels.fatal\n  },\n  error: {\n    level: LogLevels.error\n  },\n  // Level 1\n  warn: {\n    level: LogLevels.warn\n  },\n  // Level 2\n  log: {\n    level: LogLevels.log\n  },\n  // Level 3\n  info: {\n    level: LogLevels.info\n  },\n  success: {\n    level: LogLevels.success\n  },\n  fail: {\n    level: LogLevels.fail\n  },\n  ready: {\n    level: LogLevels.info\n  },\n  start: {\n    level: LogLevels.info\n  },\n  box: {\n    level: LogLevels.info\n  },\n  // Level 4\n  debug: {\n    level: LogLevels.debug\n  },\n  // Level 5\n  trace: {\n    level: LogLevels.trace\n  },\n  // Verbose\n  verbose: {\n    level: LogLevels.verbose\n  }\n};\n\nfunction isPlainObject$1(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject$1(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === undefined) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isLogObj(arg) {\n  if (!isPlainObject(arg)) {\n    return false;\n  }\n  if (!arg.message && !arg.args) {\n    return false;\n  }\n  if (arg.stack) {\n    return false;\n  }\n  return true;\n}\n\nlet paused = false;\nconst queue = [];\nclass Consola {\n  options;\n  _lastLog;\n  _mockFn;\n  /**\n   * Creates an instance of Consola with specified options or defaults.\n   *\n   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.\n   */\n  constructor(options = {}) {\n    const types = options.types || LogTypes;\n    this.options = defu(\n      {\n        ...options,\n        defaults: { ...options.defaults },\n        level: _normalizeLogLevel(options.level, types),\n        reporters: [...options.reporters || []]\n      },\n      {\n        types: LogTypes,\n        throttle: 1e3,\n        throttleMin: 5,\n        formatOptions: {\n          date: true,\n          colors: false,\n          compact: true\n        }\n      }\n    );\n    for (const type in types) {\n      const defaults = {\n        type,\n        ...this.options.defaults,\n        ...types[type]\n      };\n      this[type] = this._wrapLogFn(defaults);\n      this[type].raw = this._wrapLogFn(\n        defaults,\n        true\n      );\n    }\n    if (this.options.mockFn) {\n      this.mockTypes();\n    }\n    this._lastLog = {};\n  }\n  /**\n   * Gets the current log level of the Consola instance.\n   *\n   * @returns {number} The current log level.\n   */\n  get level() {\n    return this.options.level;\n  }\n  /**\n   * Sets the minimum log level that will be output by the instance.\n   *\n   * @param {number} level - The new log level to set.\n   */\n  set level(level) {\n    this.options.level = _normalizeLogLevel(\n      level,\n      this.options.types,\n      this.options.level\n    );\n  }\n  /**\n   * Displays a prompt to the user and returns the response.\n   * Throw an error if `prompt` is not supported by the current configuration.\n   *\n   * @template T\n   * @param {string} message - The message to display in the prompt.\n   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.\n   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.\n   */\n  prompt(message, opts) {\n    if (!this.options.prompt) {\n      throw new Error(\"prompt is not supported!\");\n    }\n    return this.options.prompt(message, opts);\n  }\n  /**\n   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.\n   *\n   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  create(options) {\n    const instance = new Consola({\n      ...this.options,\n      ...options\n    });\n    if (this._mockFn) {\n      instance.mockTypes(this._mockFn);\n    }\n    return instance;\n  }\n  /**\n   * Creates a new Consola instance with the specified default log object properties.\n   *\n   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  withDefaults(defaults) {\n    return this.create({\n      ...this.options,\n      defaults: {\n        ...this.options.defaults,\n        ...defaults\n      }\n    });\n  }\n  /**\n   * Creates a new Consola instance with a specified tag, which will be included in every log.\n   *\n   * @param {string} tag - The tag to include in each log of the new instance.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  withTag(tag) {\n    return this.withDefaults({\n      tag: this.options.defaults.tag ? this.options.defaults.tag + \":\" + tag : tag\n    });\n  }\n  /**\n   * Adds a custom reporter to the Consola instance.\n   * Reporters will be called for each log message, depending on their implementation and log level.\n   *\n   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  addReporter(reporter) {\n    this.options.reporters.push(reporter);\n    return this;\n  }\n  /**\n   * Removes a custom reporter from the Consola instance.\n   * If no reporter is specified, all reporters will be removed.\n   *\n   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  removeReporter(reporter) {\n    if (reporter) {\n      const i = this.options.reporters.indexOf(reporter);\n      if (i !== -1) {\n        return this.options.reporters.splice(i, 1);\n      }\n    } else {\n      this.options.reporters.splice(0);\n    }\n    return this;\n  }\n  /**\n   * Replaces all reporters of the Consola instance with the specified array of reporters.\n   *\n   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  setReporters(reporters) {\n    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];\n    return this;\n  }\n  wrapAll() {\n    this.wrapConsole();\n    this.wrapStd();\n  }\n  restoreAll() {\n    this.restoreConsole();\n    this.restoreStd();\n  }\n  /**\n   * Overrides console methods with Consola logging methods for consistent logging.\n   */\n  wrapConsole() {\n    for (const type in this.options.types) {\n      if (!console[\"__\" + type]) {\n        console[\"__\" + type] = console[type];\n      }\n      console[type] = this[type].raw;\n    }\n  }\n  /**\n   * Restores the original console methods, removing Consola overrides.\n   */\n  restoreConsole() {\n    for (const type in this.options.types) {\n      if (console[\"__\" + type]) {\n        console[type] = console[\"__\" + type];\n        delete console[\"__\" + type];\n      }\n    }\n  }\n  /**\n   * Overrides standard output and error streams to redirect them through Consola.\n   */\n  wrapStd() {\n    this._wrapStream(this.options.stdout, \"log\");\n    this._wrapStream(this.options.stderr, \"log\");\n  }\n  _wrapStream(stream, type) {\n    if (!stream) {\n      return;\n    }\n    if (!stream.__write) {\n      stream.__write = stream.write;\n    }\n    stream.write = (data) => {\n      this[type].raw(String(data).trim());\n    };\n  }\n  /**\n   * Restores the original standard output and error streams, removing the Consola redirection.\n   */\n  restoreStd() {\n    this._restoreStream(this.options.stdout);\n    this._restoreStream(this.options.stderr);\n  }\n  _restoreStream(stream) {\n    if (!stream) {\n      return;\n    }\n    if (stream.__write) {\n      stream.write = stream.__write;\n      delete stream.__write;\n    }\n  }\n  /**\n   * Pauses logging, queues incoming logs until resumed.\n   */\n  pauseLogs() {\n    paused = true;\n  }\n  /**\n   * Resumes logging, processing any queued logs.\n   */\n  resumeLogs() {\n    paused = false;\n    const _queue = queue.splice(0);\n    for (const item of _queue) {\n      item[0]._logFn(item[1], item[2]);\n    }\n  }\n  /**\n   * Replaces logging methods with mocks if a mock function is provided.\n   *\n   * @param {ConsolaOptions[\"mockFn\"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions[\"mockFn\"]}.\n   */\n  mockTypes(mockFn) {\n    const _mockFn = mockFn || this.options.mockFn;\n    this._mockFn = _mockFn;\n    if (typeof _mockFn !== \"function\") {\n      return;\n    }\n    for (const type in this.options.types) {\n      this[type] = _mockFn(type, this.options.types[type]) || this[type];\n      this[type].raw = this[type];\n    }\n  }\n  _wrapLogFn(defaults, isRaw) {\n    return (...args) => {\n      if (paused) {\n        queue.push([this, defaults, args, isRaw]);\n        return;\n      }\n      return this._logFn(defaults, args, isRaw);\n    };\n  }\n  _logFn(defaults, args, isRaw) {\n    if ((defaults.level || 0) > this.level) {\n      return false;\n    }\n    const logObj = {\n      date: /* @__PURE__ */ new Date(),\n      args: [],\n      ...defaults,\n      level: _normalizeLogLevel(defaults.level, this.options.types)\n    };\n    if (!isRaw && args.length === 1 && isLogObj(args[0])) {\n      Object.assign(logObj, args[0]);\n    } else {\n      logObj.args = [...args];\n    }\n    if (logObj.message) {\n      logObj.args.unshift(logObj.message);\n      delete logObj.message;\n    }\n    if (logObj.additional) {\n      if (!Array.isArray(logObj.additional)) {\n        logObj.additional = logObj.additional.split(\"\\n\");\n      }\n      logObj.args.push(\"\\n\" + logObj.additional.join(\"\\n\"));\n      delete logObj.additional;\n    }\n    logObj.type = typeof logObj.type === \"string\" ? logObj.type.toLowerCase() : \"log\";\n    logObj.tag = typeof logObj.tag === \"string\" ? logObj.tag : \"\";\n    const resolveLog = (newLog = false) => {\n      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;\n      if (this._lastLog.object && repeated > 0) {\n        const args2 = [...this._lastLog.object.args];\n        if (repeated > 1) {\n          args2.push(`(repeated ${repeated} times)`);\n        }\n        this._log({ ...this._lastLog.object, args: args2 });\n        this._lastLog.count = 1;\n      }\n      if (newLog) {\n        this._lastLog.object = logObj;\n        this._log(logObj);\n      }\n    };\n    clearTimeout(this._lastLog.timeout);\n    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;\n    this._lastLog.time = logObj.date;\n    if (diffTime < this.options.throttle) {\n      try {\n        const serializedLog = JSON.stringify([\n          logObj.type,\n          logObj.tag,\n          logObj.args\n        ]);\n        const isSameLog = this._lastLog.serialized === serializedLog;\n        this._lastLog.serialized = serializedLog;\n        if (isSameLog) {\n          this._lastLog.count = (this._lastLog.count || 0) + 1;\n          if (this._lastLog.count > this.options.throttleMin) {\n            this._lastLog.timeout = setTimeout(\n              resolveLog,\n              this.options.throttle\n            );\n            return;\n          }\n        }\n      } catch {\n      }\n    }\n    resolveLog(true);\n  }\n  _log(logObj) {\n    for (const reporter of this.options.reporters) {\n      reporter.log(logObj, {\n        options: this.options\n      });\n    }\n  }\n}\nfunction _normalizeLogLevel(input, types = {}, defaultLevel = 3) {\n  if (input === undefined) {\n    return defaultLevel;\n  }\n  if (typeof input === \"number\") {\n    return input;\n  }\n  if (types[input] && types[input].level !== undefined) {\n    return types[input].level;\n  }\n  return defaultLevel;\n}\nConsola.prototype.add = Consola.prototype.addReporter;\nConsola.prototype.remove = Consola.prototype.removeReporter;\nConsola.prototype.clear = Consola.prototype.removeReporter;\nConsola.prototype.withScope = Consola.prototype.withTag;\nConsola.prototype.mock = Consola.prototype.mockTypes;\nConsola.prototype.pause = Consola.prototype.pauseLogs;\nConsola.prototype.resume = Consola.prototype.resumeLogs;\nfunction createConsola(options = {}) {\n  return new Consola(options);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29uc29sYS9kaXN0L2NvcmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FzZWNvYnJhLWRldi8uL25vZGVfbW9kdWxlcy9jb25zb2xhL2Rpc3QvY29yZS5tanM/YTVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dMZXZlbHMgPSB7XG4gIHNpbGVudDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICBmYXRhbDogMCxcbiAgZXJyb3I6IDAsXG4gIHdhcm46IDEsXG4gIGxvZzogMixcbiAgaW5mbzogMyxcbiAgc3VjY2VzczogMyxcbiAgZmFpbDogMyxcbiAgcmVhZHk6IDMsXG4gIHN0YXJ0OiAzLFxuICBib3g6IDMsXG4gIGRlYnVnOiA0LFxuICB0cmFjZTogNSxcbiAgdmVyYm9zZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG59O1xuY29uc3QgTG9nVHlwZXMgPSB7XG4gIC8vIFNpbGVudFxuICBzaWxlbnQ6IHtcbiAgICBsZXZlbDogLTFcbiAgfSxcbiAgLy8gTGV2ZWwgMFxuICBmYXRhbDoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuZmF0YWxcbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmVycm9yXG4gIH0sXG4gIC8vIExldmVsIDFcbiAgd2Fybjoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMud2FyblxuICB9LFxuICAvLyBMZXZlbCAyXG4gIGxvZzoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMubG9nXG4gIH0sXG4gIC8vIExldmVsIDNcbiAgaW5mbzoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuaW5mb1xuICB9LFxuICBzdWNjZXNzOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5zdWNjZXNzXG4gIH0sXG4gIGZhaWw6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmZhaWxcbiAgfSxcbiAgcmVhZHk6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmluZm9cbiAgfSxcbiAgc3RhcnQ6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmluZm9cbiAgfSxcbiAgYm94OiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5pbmZvXG4gIH0sXG4gIC8vIExldmVsIDRcbiAgZGVidWc6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmRlYnVnXG4gIH0sXG4gIC8vIExldmVsIDVcbiAgdHJhY2U6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLnRyYWNlXG4gIH0sXG4gIC8vIFZlcmJvc2VcbiAgdmVyYm9zZToge1xuICAgIGxldmVsOiBMb2dMZXZlbHMudmVyYm9zZVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0JDEodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG90eXBlICE9PSBudWxsICYmIHByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE1vZHVsZV1cIjtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2RlZnUoYmFzZU9iamVjdCwgZGVmYXVsdHMsIG5hbWVzcGFjZSA9IFwiLlwiLCBtZXJnZXIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0JDEoZGVmYXVsdHMpKSB7XG4gICAgcmV0dXJuIF9kZWZ1KGJhc2VPYmplY3QsIHt9LCBuYW1lc3BhY2UsIG1lcmdlcik7XG4gIH1cbiAgY29uc3Qgb2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBiYXNlT2JqZWN0KSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBrZXkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gYmFzZU9iamVjdFtrZXldO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1lcmdlciAmJiBtZXJnZXIob2JqZWN0LCBrZXksIHZhbHVlLCBuYW1lc3BhY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkob2JqZWN0W2tleV0pKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IFsuLi52YWx1ZSwgLi4ub2JqZWN0W2tleV1dO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCQxKHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0JDEob2JqZWN0W2tleV0pKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IF9kZWZ1KFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2JqZWN0W2tleV0sXG4gICAgICAgIChuYW1lc3BhY2UgPyBgJHtuYW1lc3BhY2V9LmAgOiBcIlwiKSArIGtleS50b1N0cmluZygpLFxuICAgICAgICBtZXJnZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZ1KG1lcmdlcikge1xuICByZXR1cm4gKC4uLmFyZ3VtZW50c18pID0+IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1hcnJheS1yZWR1Y2VcbiAgICBhcmd1bWVudHNfLnJlZHVjZSgocCwgYykgPT4gX2RlZnUocCwgYywgXCJcIiwgbWVyZ2VyKSwge30pXG4gICk7XG59XG5jb25zdCBkZWZ1ID0gY3JlYXRlRGVmdSgpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc0xvZ09iaihhcmcpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFhcmcubWVzc2FnZSAmJiAhYXJnLmFyZ3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFyZy5zdGFjaykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubGV0IHBhdXNlZCA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmNsYXNzIENvbnNvbGEge1xuICBvcHRpb25zO1xuICBfbGFzdExvZztcbiAgX21vY2tGbjtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29uc29sYSB3aXRoIHNwZWNpZmllZCBvcHRpb25zIG9yIGRlZmF1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Q29uc29sYU9wdGlvbnM+fSBbb3B0aW9ucz17fV0gLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBDb25zb2xhIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHlwZXMgPSBvcHRpb25zLnR5cGVzIHx8IExvZ1R5cGVzO1xuICAgIHRoaXMub3B0aW9ucyA9IGRlZnUoXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRzOiB7IC4uLm9wdGlvbnMuZGVmYXVsdHMgfSxcbiAgICAgICAgbGV2ZWw6IF9ub3JtYWxpemVMb2dMZXZlbChvcHRpb25zLmxldmVsLCB0eXBlcyksXG4gICAgICAgIHJlcG9ydGVyczogWy4uLm9wdGlvbnMucmVwb3J0ZXJzIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZXM6IExvZ1R5cGVzLFxuICAgICAgICB0aHJvdHRsZTogMWUzLFxuICAgICAgICB0aHJvdHRsZU1pbjogNSxcbiAgICAgICAgZm9ybWF0T3B0aW9uczoge1xuICAgICAgICAgIGRhdGU6IHRydWUsXG4gICAgICAgICAgY29sb3JzOiBmYWxzZSxcbiAgICAgICAgICBjb21wYWN0OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGZvciAoY29uc3QgdHlwZSBpbiB0eXBlcykge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgLi4udHlwZXNbdHlwZV1cbiAgICAgIH07XG4gICAgICB0aGlzW3R5cGVdID0gdGhpcy5fd3JhcExvZ0ZuKGRlZmF1bHRzKTtcbiAgICAgIHRoaXNbdHlwZV0ucmF3ID0gdGhpcy5fd3JhcExvZ0ZuKFxuICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5tb2NrRm4pIHtcbiAgICAgIHRoaXMubW9ja1R5cGVzKCk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RMb2cgPSB7fTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBsb2cgbGV2ZWwgb2YgdGhlIENvbnNvbGEgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICovXG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtaW5pbXVtIGxvZyBsZXZlbCB0aGF0IHdpbGwgYmUgb3V0cHV0IGJ5IHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIC0gVGhlIG5ldyBsb2cgbGV2ZWwgdG8gc2V0LlxuICAgKi9cbiAgc2V0IGxldmVsKGxldmVsKSB7XG4gICAgdGhpcy5vcHRpb25zLmxldmVsID0gX25vcm1hbGl6ZUxvZ0xldmVsKFxuICAgICAgbGV2ZWwsXG4gICAgICB0aGlzLm9wdGlvbnMudHlwZXMsXG4gICAgICB0aGlzLm9wdGlvbnMubGV2ZWxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwbGF5cyBhIHByb21wdCB0byB0aGUgdXNlciBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAqIFRocm93IGFuIGVycm9yIGlmIGBwcm9tcHRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBwcm9tcHQuXG4gICAqIEBwYXJhbSB7VH0gW29wdHNdIC0gT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHByb21wdC4gU2VlIHtAbGluayBQcm9tcHRPcHRpb25zfS5cbiAgICogQHJldHVybnMge3Byb21pc2U8VD59IEEgcHJvbWlzZSB0aGF0IGluZmVyIHdpdGggdGhlIHByb21wdCBvcHRpb25zLiBTZWUge0BsaW5rIFByb21wdE9wdGlvbnN9LlxuICAgKi9cbiAgcHJvbXB0KG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByb21wdCBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcm9tcHQobWVzc2FnZSwgb3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29uc29sYSwgaW5oZXJpdGluZyBvcHRpb25zIGZyb20gdGhlIGN1cnJlbnQgaW5zdGFuY2UsIHdpdGggcG9zc2libGUgb3ZlcnJpZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Q29uc29sYU9wdGlvbnM+fSBvcHRpb25zIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIGZvciB0aGUgbmV3IGluc3RhbmNlLiBTZWUge0BsaW5rIENvbnNvbGFPcHRpb25zfS5cbiAgICogQHJldHVybnMge0NvbnNvbGFJbnN0YW5jZX0gQSBuZXcgQ29uc29sYSBpbnN0YW5jZS4gU2VlIHtAbGluayBDb25zb2xhSW5zdGFuY2V9LlxuICAgKi9cbiAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDb25zb2xhKHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fbW9ja0ZuKSB7XG4gICAgICBpbnN0YW5jZS5tb2NrVHlwZXModGhpcy5fbW9ja0ZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENvbnNvbGEgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGRlZmF1bHQgbG9nIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0lucHV0TG9nT2JqZWN0fSBkZWZhdWx0cyAtIERlZmF1bHQgcHJvcGVydGllcyB0byBpbmNsdWRlIGluIGFueSBsb2cgZnJvbSB0aGUgbmV3IGluc3RhbmNlLiBTZWUge0BsaW5rIElucHV0TG9nT2JqZWN0fS5cbiAgICogQHJldHVybnMge0NvbnNvbGFJbnN0YW5jZX0gQSBuZXcgQ29uc29sYSBpbnN0YW5jZS4gU2VlIHtAbGluayBDb25zb2xhSW5zdGFuY2V9LlxuICAgKi9cbiAgd2l0aERlZmF1bHRzKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgLi4uZGVmYXVsdHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb25zb2xhIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgdGFnLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIGV2ZXJ5IGxvZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyAtIFRoZSB0YWcgdG8gaW5jbHVkZSBpbiBlYWNoIGxvZyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7Q29uc29sYUluc3RhbmNlfSBBIG5ldyBDb25zb2xhIGluc3RhbmNlLiBTZWUge0BsaW5rIENvbnNvbGFJbnN0YW5jZX0uXG4gICAqL1xuICB3aXRoVGFnKHRhZykge1xuICAgIHJldHVybiB0aGlzLndpdGhEZWZhdWx0cyh7XG4gICAgICB0YWc6IHRoaXMub3B0aW9ucy5kZWZhdWx0cy50YWcgPyB0aGlzLm9wdGlvbnMuZGVmYXVsdHMudGFnICsgXCI6XCIgKyB0YWcgOiB0YWdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGN1c3RvbSByZXBvcnRlciB0byB0aGUgQ29uc29sYSBpbnN0YW5jZS5cbiAgICogUmVwb3J0ZXJzIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGxvZyBtZXNzYWdlLCBkZXBlbmRpbmcgb24gdGhlaXIgaW1wbGVtZW50YXRpb24gYW5kIGxvZyBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtDb25zb2xhUmVwb3J0ZXJ9IHJlcG9ydGVyIC0gVGhlIHJlcG9ydGVyIHRvIGFkZC4gU2VlIHtAbGluayBDb25zb2xhUmVwb3J0ZXJ9LlxuICAgKiBAcmV0dXJucyB7Q29uc29sYX0gVGhlIGN1cnJlbnQgQ29uc29sYSBpbnN0YW5jZS5cbiAgICovXG4gIGFkZFJlcG9ydGVyKHJlcG9ydGVyKSB7XG4gICAgdGhpcy5vcHRpb25zLnJlcG9ydGVycy5wdXNoKHJlcG9ydGVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGN1c3RvbSByZXBvcnRlciBmcm9tIHRoZSBDb25zb2xhIGluc3RhbmNlLlxuICAgKiBJZiBubyByZXBvcnRlciBpcyBzcGVjaWZpZWQsIGFsbCByZXBvcnRlcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnNvbGFSZXBvcnRlcn0gcmVwb3J0ZXIgLSBUaGUgcmVwb3J0ZXIgdG8gcmVtb3ZlLiBTZWUge0BsaW5rIENvbnNvbGFSZXBvcnRlcn0uXG4gICAqIEByZXR1cm5zIHtDb25zb2xhfSBUaGUgY3VycmVudCBDb25zb2xhIGluc3RhbmNlLlxuICAgKi9cbiAgcmVtb3ZlUmVwb3J0ZXIocmVwb3J0ZXIpIHtcbiAgICBpZiAocmVwb3J0ZXIpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLmluZGV4T2YocmVwb3J0ZXIpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnJlcG9ydGVycy5zcGxpY2UoMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgcmVwb3J0ZXJzIG9mIHRoZSBDb25zb2xhIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBhcnJheSBvZiByZXBvcnRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29uc29sYVJlcG9ydGVyW119IHJlcG9ydGVycyAtIFRoZSBuZXcgcmVwb3J0ZXJzIHRvIHNldC4gU2VlIHtAbGluayBDb25zb2xhUmVwb3J0ZXJ9LlxuICAgKiBAcmV0dXJucyB7Q29uc29sYX0gVGhlIGN1cnJlbnQgQ29uc29sYSBpbnN0YW5jZS5cbiAgICovXG4gIHNldFJlcG9ydGVycyhyZXBvcnRlcnMpIHtcbiAgICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzID0gQXJyYXkuaXNBcnJheShyZXBvcnRlcnMpID8gcmVwb3J0ZXJzIDogW3JlcG9ydGVyc107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgd3JhcEFsbCgpIHtcbiAgICB0aGlzLndyYXBDb25zb2xlKCk7XG4gICAgdGhpcy53cmFwU3RkKCk7XG4gIH1cbiAgcmVzdG9yZUFsbCgpIHtcbiAgICB0aGlzLnJlc3RvcmVDb25zb2xlKCk7XG4gICAgdGhpcy5yZXN0b3JlU3RkKCk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBjb25zb2xlIG1ldGhvZHMgd2l0aCBDb25zb2xhIGxvZ2dpbmcgbWV0aG9kcyBmb3IgY29uc2lzdGVudCBsb2dnaW5nLlxuICAgKi9cbiAgd3JhcENvbnNvbGUoKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMub3B0aW9ucy50eXBlcykge1xuICAgICAgaWYgKCFjb25zb2xlW1wiX19cIiArIHR5cGVdKSB7XG4gICAgICAgIGNvbnNvbGVbXCJfX1wiICsgdHlwZV0gPSBjb25zb2xlW3R5cGVdO1xuICAgICAgfVxuICAgICAgY29uc29sZVt0eXBlXSA9IHRoaXNbdHlwZV0ucmF3O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGNvbnNvbGUgbWV0aG9kcywgcmVtb3ZpbmcgQ29uc29sYSBvdmVycmlkZXMuXG4gICAqL1xuICByZXN0b3JlQ29uc29sZSgpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy5vcHRpb25zLnR5cGVzKSB7XG4gICAgICBpZiAoY29uc29sZVtcIl9fXCIgKyB0eXBlXSkge1xuICAgICAgICBjb25zb2xlW3R5cGVdID0gY29uc29sZVtcIl9fXCIgKyB0eXBlXTtcbiAgICAgICAgZGVsZXRlIGNvbnNvbGVbXCJfX1wiICsgdHlwZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgc3RhbmRhcmQgb3V0cHV0IGFuZCBlcnJvciBzdHJlYW1zIHRvIHJlZGlyZWN0IHRoZW0gdGhyb3VnaCBDb25zb2xhLlxuICAgKi9cbiAgd3JhcFN0ZCgpIHtcbiAgICB0aGlzLl93cmFwU3RyZWFtKHRoaXMub3B0aW9ucy5zdGRvdXQsIFwibG9nXCIpO1xuICAgIHRoaXMuX3dyYXBTdHJlYW0odGhpcy5vcHRpb25zLnN0ZGVyciwgXCJsb2dcIik7XG4gIH1cbiAgX3dyYXBTdHJlYW0oc3RyZWFtLCB0eXBlKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uX193cml0ZSkge1xuICAgICAgc3RyZWFtLl9fd3JpdGUgPSBzdHJlYW0ud3JpdGU7XG4gICAgfVxuICAgIHN0cmVhbS53cml0ZSA9IChkYXRhKSA9PiB7XG4gICAgICB0aGlzW3R5cGVdLnJhdyhTdHJpbmcoZGF0YSkudHJpbSgpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhbmRhcmQgb3V0cHV0IGFuZCBlcnJvciBzdHJlYW1zLCByZW1vdmluZyB0aGUgQ29uc29sYSByZWRpcmVjdGlvbi5cbiAgICovXG4gIHJlc3RvcmVTdGQoKSB7XG4gICAgdGhpcy5fcmVzdG9yZVN0cmVhbSh0aGlzLm9wdGlvbnMuc3Rkb3V0KTtcbiAgICB0aGlzLl9yZXN0b3JlU3RyZWFtKHRoaXMub3B0aW9ucy5zdGRlcnIpO1xuICB9XG4gIF9yZXN0b3JlU3RyZWFtKHN0cmVhbSkge1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdHJlYW0uX193cml0ZSkge1xuICAgICAgc3RyZWFtLndyaXRlID0gc3RyZWFtLl9fd3JpdGU7XG4gICAgICBkZWxldGUgc3RyZWFtLl9fd3JpdGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXVzZXMgbG9nZ2luZywgcXVldWVzIGluY29taW5nIGxvZ3MgdW50aWwgcmVzdW1lZC5cbiAgICovXG4gIHBhdXNlTG9ncygpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIGxvZ2dpbmcsIHByb2Nlc3NpbmcgYW55IHF1ZXVlZCBsb2dzLlxuICAgKi9cbiAgcmVzdW1lTG9ncygpIHtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBfcXVldWUgPSBxdWV1ZS5zcGxpY2UoMCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIF9xdWV1ZSkge1xuICAgICAgaXRlbVswXS5fbG9nRm4oaXRlbVsxXSwgaXRlbVsyXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBsb2dnaW5nIG1ldGhvZHMgd2l0aCBtb2NrcyBpZiBhIG1vY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29uc29sYU9wdGlvbnNbXCJtb2NrRm5cIl19IG1vY2tGbiAtIFRoZSBmdW5jdGlvbiB0byB1c2UgZm9yIG1vY2tpbmcgbG9nZ2luZyBtZXRob2RzLiBTZWUge0BsaW5rIENvbnNvbGFPcHRpb25zW1wibW9ja0ZuXCJdfS5cbiAgICovXG4gIG1vY2tUeXBlcyhtb2NrRm4pIHtcbiAgICBjb25zdCBfbW9ja0ZuID0gbW9ja0ZuIHx8IHRoaXMub3B0aW9ucy5tb2NrRm47XG4gICAgdGhpcy5fbW9ja0ZuID0gX21vY2tGbjtcbiAgICBpZiAodHlwZW9mIF9tb2NrRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy5vcHRpb25zLnR5cGVzKSB7XG4gICAgICB0aGlzW3R5cGVdID0gX21vY2tGbih0eXBlLCB0aGlzLm9wdGlvbnMudHlwZXNbdHlwZV0pIHx8IHRoaXNbdHlwZV07XG4gICAgICB0aGlzW3R5cGVdLnJhdyA9IHRoaXNbdHlwZV07XG4gICAgfVxuICB9XG4gIF93cmFwTG9nRm4oZGVmYXVsdHMsIGlzUmF3KSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goW3RoaXMsIGRlZmF1bHRzLCBhcmdzLCBpc1Jhd10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9nRm4oZGVmYXVsdHMsIGFyZ3MsIGlzUmF3KTtcbiAgICB9O1xuICB9XG4gIF9sb2dGbihkZWZhdWx0cywgYXJncywgaXNSYXcpIHtcbiAgICBpZiAoKGRlZmF1bHRzLmxldmVsIHx8IDApID4gdGhpcy5sZXZlbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsb2dPYmogPSB7XG4gICAgICBkYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIGFyZ3M6IFtdLFxuICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICBsZXZlbDogX25vcm1hbGl6ZUxvZ0xldmVsKGRlZmF1bHRzLmxldmVsLCB0aGlzLm9wdGlvbnMudHlwZXMpXG4gICAgfTtcbiAgICBpZiAoIWlzUmF3ICYmIGFyZ3MubGVuZ3RoID09PSAxICYmIGlzTG9nT2JqKGFyZ3NbMF0pKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGxvZ09iaiwgYXJnc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ09iai5hcmdzID0gWy4uLmFyZ3NdO1xuICAgIH1cbiAgICBpZiAobG9nT2JqLm1lc3NhZ2UpIHtcbiAgICAgIGxvZ09iai5hcmdzLnVuc2hpZnQobG9nT2JqLm1lc3NhZ2UpO1xuICAgICAgZGVsZXRlIGxvZ09iai5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAobG9nT2JqLmFkZGl0aW9uYWwpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsb2dPYmouYWRkaXRpb25hbCkpIHtcbiAgICAgICAgbG9nT2JqLmFkZGl0aW9uYWwgPSBsb2dPYmouYWRkaXRpb25hbC5zcGxpdChcIlxcblwiKTtcbiAgICAgIH1cbiAgICAgIGxvZ09iai5hcmdzLnB1c2goXCJcXG5cIiArIGxvZ09iai5hZGRpdGlvbmFsLmpvaW4oXCJcXG5cIikpO1xuICAgICAgZGVsZXRlIGxvZ09iai5hZGRpdGlvbmFsO1xuICAgIH1cbiAgICBsb2dPYmoudHlwZSA9IHR5cGVvZiBsb2dPYmoudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGxvZ09iai50eXBlLnRvTG93ZXJDYXNlKCkgOiBcImxvZ1wiO1xuICAgIGxvZ09iai50YWcgPSB0eXBlb2YgbG9nT2JqLnRhZyA9PT0gXCJzdHJpbmdcIiA/IGxvZ09iai50YWcgOiBcIlwiO1xuICAgIGNvbnN0IHJlc29sdmVMb2cgPSAobmV3TG9nID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHJlcGVhdGVkID0gKHRoaXMuX2xhc3RMb2cuY291bnQgfHwgMCkgLSB0aGlzLm9wdGlvbnMudGhyb3R0bGVNaW47XG4gICAgICBpZiAodGhpcy5fbGFzdExvZy5vYmplY3QgJiYgcmVwZWF0ZWQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MyID0gWy4uLnRoaXMuX2xhc3RMb2cub2JqZWN0LmFyZ3NdO1xuICAgICAgICBpZiAocmVwZWF0ZWQgPiAxKSB7XG4gICAgICAgICAgYXJnczIucHVzaChgKHJlcGVhdGVkICR7cmVwZWF0ZWR9IHRpbWVzKWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZyh7IC4uLnRoaXMuX2xhc3RMb2cub2JqZWN0LCBhcmdzOiBhcmdzMiB9KTtcbiAgICAgICAgdGhpcy5fbGFzdExvZy5jb3VudCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAobmV3TG9nKSB7XG4gICAgICAgIHRoaXMuX2xhc3RMb2cub2JqZWN0ID0gbG9nT2JqO1xuICAgICAgICB0aGlzLl9sb2cobG9nT2JqKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9sYXN0TG9nLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gdGhpcy5fbGFzdExvZy50aW1lICYmIGxvZ09iai5kYXRlID8gbG9nT2JqLmRhdGUuZ2V0VGltZSgpIC0gdGhpcy5fbGFzdExvZy50aW1lLmdldFRpbWUoKSA6IDA7XG4gICAgdGhpcy5fbGFzdExvZy50aW1lID0gbG9nT2JqLmRhdGU7XG4gICAgaWYgKGRpZmZUaW1lIDwgdGhpcy5vcHRpb25zLnRocm90dGxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTG9nID0gSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgIGxvZ09iai50eXBlLFxuICAgICAgICAgIGxvZ09iai50YWcsXG4gICAgICAgICAgbG9nT2JqLmFyZ3NcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGlzU2FtZUxvZyA9IHRoaXMuX2xhc3RMb2cuc2VyaWFsaXplZCA9PT0gc2VyaWFsaXplZExvZztcbiAgICAgICAgdGhpcy5fbGFzdExvZy5zZXJpYWxpemVkID0gc2VyaWFsaXplZExvZztcbiAgICAgICAgaWYgKGlzU2FtZUxvZykge1xuICAgICAgICAgIHRoaXMuX2xhc3RMb2cuY291bnQgPSAodGhpcy5fbGFzdExvZy5jb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgaWYgKHRoaXMuX2xhc3RMb2cuY291bnQgPiB0aGlzLm9wdGlvbnMudGhyb3R0bGVNaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RMb2cudGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgIHJlc29sdmVMb2csXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aHJvdHRsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlTG9nKHRydWUpO1xuICB9XG4gIF9sb2cobG9nT2JqKSB7XG4gICAgZm9yIChjb25zdCByZXBvcnRlciBvZiB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzKSB7XG4gICAgICByZXBvcnRlci5sb2cobG9nT2JqLCB7XG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplTG9nTGV2ZWwoaW5wdXQsIHR5cGVzID0ge30sIGRlZmF1bHRMZXZlbCA9IDMpIHtcbiAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGVmYXVsdExldmVsO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKHR5cGVzW2lucHV0XSAmJiB0eXBlc1tpbnB1dF0ubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0eXBlc1tpbnB1dF0ubGV2ZWw7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbn1cbkNvbnNvbGEucHJvdG90eXBlLmFkZCA9IENvbnNvbGEucHJvdG90eXBlLmFkZFJlcG9ydGVyO1xuQ29uc29sYS5wcm90b3R5cGUucmVtb3ZlID0gQ29uc29sYS5wcm90b3R5cGUucmVtb3ZlUmVwb3J0ZXI7XG5Db25zb2xhLnByb3RvdHlwZS5jbGVhciA9IENvbnNvbGEucHJvdG90eXBlLnJlbW92ZVJlcG9ydGVyO1xuQ29uc29sYS5wcm90b3R5cGUud2l0aFNjb3BlID0gQ29uc29sYS5wcm90b3R5cGUud2l0aFRhZztcbkNvbnNvbGEucHJvdG90eXBlLm1vY2sgPSBDb25zb2xhLnByb3RvdHlwZS5tb2NrVHlwZXM7XG5Db25zb2xhLnByb3RvdHlwZS5wYXVzZSA9IENvbnNvbGEucHJvdG90eXBlLnBhdXNlTG9ncztcbkNvbnNvbGEucHJvdG90eXBlLnJlc3VtZSA9IENvbnNvbGEucHJvdG90eXBlLnJlc3VtZUxvZ3M7XG5mdW5jdGlvbiBjcmVhdGVDb25zb2xhKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbmV3IENvbnNvbGEob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IENvbnNvbGEsIExvZ0xldmVscywgTG9nVHlwZXMsIGNyZWF0ZUNvbnNvbGEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/consola/dist/core.mjs\n");

/***/ })

};
;